22:07:59|RAP|WARN|: Dangling pointer detected in function "poll"
warning: Dangling pointer detected.
   --> src/driver/net/mod.rs:256:1
    |
256 | / pub fn poll<D>(&self, device: &mut D) -> bool
257 | |     where
258 | |         D: smoltcp::phy::Device + ?Sized,
259 | |     {
260 | |         let timestamp = crate::time::Instant::now().into();
261 | |         let mut sockets = self.sockets.lock_irqsave();
262 | |         let mut interface = self.smol_iface.lock_irqsave();
263 | |
264 | |         let (has_events, poll_at) = {
265 | |             (
266 | |                 matches!(
267 | |                     interface.poll(timestamp, device, &mut sockets),
268 | |                     smoltcp::iface::PollResult::SocketStateChanged
269 | |                 ),
270 | |                 loop {
271 | |                     let poll_at = interface.poll_at(timestamp, &sockets);
272 | |                     let Some(instant) = poll_at else {
273 | |                         break poll_at;
274 | |                     };
275 | |                     if instant > timestamp {
276 | |                         break poll_at;
277 | |                     }
278 | |                 },
279 | |             )
280 | |         };
281 | |
282 | |         // drop sockets here to avoid deadlock
283 | |         drop(interface);
284 | |         drop(sockets);
285 | |         // log::info!(
286 | |         //     "polling iface {}, has_events: {}, poll_at: {:?}",
287 | |         //     self.iface_id,
288 | |         //     has_events,
289 | |         //     poll_at
290 | |         // );
291 | |
292 | |         use core::sync::atomic::Ordering;
293 | |         if let Some(instant) = poll_at {
294 | |             let _old_instant = self.poll_at_ms.load(Ordering::Relaxed);
295 | |             let new_instant = instant.total_millis() as u64;
296 | |             self.poll_at_ms.store(new_instant, Ordering::Relaxed);
297 | |
298 | |             // TODO: poll at
299 | |             // if old_instant == 0 || new_instant < old_instant {
300 | |             //     self.polling_wait_queue.wake_all();
301 | |             // }
302 | |         } else {
303 | |             self.poll_at_ms.store(0, Ordering::Relaxed);
304 | |         }
305 | |
306 | |         self.bounds.read_irqsave().iter().for_each(|bound_socket| {
307 | |             // incase our inet socket missed the event, we manually notify it each time we poll
308 | |             if has_events {
309 | |                 bound_socket.notify();
310 | |                 let _woke = bound_socket
311 | |                     .wait_queue()
312 | |                     .wakeup(Some(ProcessState::Blocked(true)));
313 | |             }
314 | |         });
315 | |
316 | |         // TODO: remove closed sockets
317 | |         // let closed_sockets = self
318 | |         //     .closing_sockets
319 | |         //     .lock_irq_disabled()
320 | |         //     .extract_if(|closing_socket| closing_socket.is_closed())
321 | |         //     .collect::<Vec<_>>();
322 | |         // drop(closed_sockets);
323 | |         has_events
324 | |     }
    | |_____- Dangling pointer (confidence 99%): Location in file src/driver/net/mod.rs line 256.
    | MIR detail: Value UNKNWON(_18446744073709551615) in poll and _1(self, src/driver/net/mod.rs:256) are alias.
    | MIR detail: UNKNWON(_18446744073709551615) in poll is dropped at BB18446744073709551615(src/driver/net/mod.rs:256); _1(self, src/driver/net/mod.rs:256) became dangling.
    |
22:07:59|RAP|WARN|: Dangling pointer detected during unwinding in function "poll"
warning: Dangling pointer detected during unwinding.
   --> src/driver/net/mod.rs:256:1
    |
256 | / pub fn poll<D>(&self, device: &mut D) -> bool
257 | |     where
258 | |         D: smoltcp::phy::Device + ?Sized,
259 | |     {
260 | |         let timestamp = crate::time::Instant::now().into();
261 | |         let mut sockets = self.sockets.lock_irqsave();
262 | |         let mut interface = self.smol_iface.lock_irqsave();
263 | |
264 | |         let (has_events, poll_at) = {
265 | |             (
266 | |                 matches!(
267 | |                     interface.poll(timestamp, device, &mut sockets),
268 | |                     smoltcp::iface::PollResult::SocketStateChanged
269 | |                 ),
270 | |                 loop {
271 | |                     let poll_at = interface.poll_at(timestamp, &sockets);
272 | |                     let Some(instant) = poll_at else {
273 | |                         break poll_at;
274 | |                     };
275 | |                     if instant > timestamp {
276 | |                         break poll_at;
277 | |                     }
278 | |                 },
279 | |             )
280 | |         };
281 | |
282 | |         // drop sockets here to avoid deadlock
283 | |         drop(interface);
284 | |         drop(sockets);
285 | |         // log::info!(
286 | |         //     "polling iface {}, has_events: {}, poll_at: {:?}",
287 | |         //     self.iface_id,
288 | |         //     has_events,
289 | |         //     poll_at
290 | |         // );
291 | |
292 | |         use core::sync::atomic::Ordering;
293 | |         if let Some(instant) = poll_at {
294 | |             let _old_instant = self.poll_at_ms.load(Ordering::Relaxed);
295 | |             let new_instant = instant.total_millis() as u64;
296 | |             self.poll_at_ms.store(new_instant, Ordering::Relaxed);
297 | |
298 | |             // TODO: poll at
299 | |             // if old_instant == 0 || new_instant < old_instant {
300 | |             //     self.polling_wait_queue.wake_all();
301 | |             // }
302 | |         } else {
303 | |             self.poll_at_ms.store(0, Ordering::Relaxed);
304 | |         }
305 | |
306 | |         self.bounds.read_irqsave().iter().for_each(|bound_socket| {
307 | |             // incase our inet socket missed the event, we manually notify it each time we poll
308 | |             if has_events {
309 | |                 bound_socket.notify();
310 | |                 let _woke = bound_socket
311 | |                     .wait_queue()
312 | |                     .wakeup(Some(ProcessState::Blocked(true)));
313 | |             }
314 | |         });
315 | |
316 | |         // TODO: remove closed sockets
317 | |         // let closed_sockets = self
318 | |         //     .closing_sockets
319 | |         //     .lock_irq_disabled()
320 | |         //     .extract_if(|closing_socket| closing_socket.is_closed())
321 | |         //     .collect::<Vec<_>>();
322 | |         // drop(closed_sockets);
323 | |         has_events
324 | |     }
    | |_____- Dangling pointer (confidence 99%): Location in file src/driver/net/mod.rs line 256.
    | MIR detail: Value UNKNWON(_18446744073709551615) in poll and _1(self, src/driver/net/mod.rs:256) are alias.
    | MIR detail: UNKNWON(_18446744073709551615) in poll is dropped at BB18446744073709551615(src/driver/net/mod.rs:256); _1(self, src/driver/net/mod.rs:256) became dangling.
    |
render dot for DefId(0:11817 ~ dragonos_kernel[9e38]::driver::net::{impl#2}::poll)
